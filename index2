<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>炫酷粒子光点交互动画</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

class Particle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random()-0.5) * 1;
        this.vy = (Math.random()-0.5) * 1;
        this.size = Math.random()*3+1;
        this.hue = Math.random()*360;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        if(this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if(this.y < 0 || this.y > canvas.height) this.vy *= -1;

        // 颜色缓慢变化
        this.hue += 0.2;
        if(this.hue > 360) this.hue -= 360;
    }

    draw() {
        ctx.beginPath();
        ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
        ctx.shadowColor = `hsl(${this.hue}, 100%, 70%)`;
        ctx.shadowBlur = 15;
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
    }
}

const particles = [];
const particleCount = 250;
for(let i=0;i<particleCount;i++){
    particles.push(new Particle(Math.random()*canvas.width, Math.random()*canvas.height));
}

let disturbance = { x:null, y:null };
canvas.addEventListener('mousemove', e => { disturbance.x = e.clientX; disturbance.y = e.clientY; });
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    disturbance.x = e.touches[0].clientX;
    disturbance.y = e.touches[0].clientY;
}, { passive: false });

function animate() {
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // 粒子间连线
    for(let i=0;i<particles.length;i++){
        for(let j=i+1;j<particles.length;j++){
            let dx = particles[i].x - particles[j].x;
            let dy = particles[i].y - particles[j].y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < 100){
                ctx.strokeStyle = `hsla(${particles[i].hue},100%,70%,${1 - dist/100})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(particles[i].x, particles[i].y);
                ctx.lineTo(particles[j].x, particles[j].y);
                ctx.stroke();
            }
        }
    }

    particles.forEach(p => {
        if(disturbance.x !== null && disturbance.y !== null){
            let dx = disturbance.x - p.x;
            let dy = disturbance.y - p.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < 150){
                let force = (150 - dist)/150 * 0.8;
                // 涡流效果：垂直施加旋转力
                let angle = Math.atan2(dy, dx);
                let spiral = 0.1 * force;
                p.vx += Math.cos(angle + Math.PI/2) * spiral;
                p.vy += Math.sin(angle + Math.PI/2) * spiral;

                // 吸引效果
                p.vx += dx * 0.002 * force;
                p.vy += dy * 0.002 * force;
            }
        }

        // 阻尼
        p.vx *= 0.95;
        p.vy *= 0.95;

        p.update();
        p.draw();
    });

    requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
</body>
</html>